════════════════════════════════════════
read_count - Reading Input
════════════════════════════════════════

THE READ SYSCALL

  movq $0, %rax         # syscall number (read = 0)
  movq $0, %rdi         # file descriptor (stdin = 0)
  movq $???, %rsi       # pointer to buffer
  movq $???, %rdx       # max bytes to read
  syscall

After syscall, %rax contains bytes actually read.


THE .BSS SECTION

The buffer is in .bss - uninitialized data. This reserves
memory at runtime without taking space in the executable.

  .section .bss
  buffer: .skip 256     # Reserve 256 bytes

To get the address of buffer:

  leaq buffer(%rip), %rsi


USING THE RETURN VALUE

The exit syscall needs the exit code in %rdi.
But read returns the byte count in %rax.

The exercise already has:
  movq %rax, %rdi       # Move byte count to exit code
  movq $60, %rax        # syscall number for exit

So you just need to implement the read syscall above.


YOUR TASK

Set up the four values and call syscall:
  - %rax = 0 (read)
  - %rdi = 0 (stdin)
  - %rsi = address of buffer
  - %rdx = 256 (buffer size)
