════════════════════════════════════════
echo - Combining Read and Write
════════════════════════════════════════

THE CHALLENGE

After read syscall:
  %rax = byte count

For write syscall, you need:
  %rax = 1 (syscall number)
  %rdx = byte count

The problem: read's return value is in %rax, but you need
to put 1 in %rax for the write syscall!


THE SOLUTION

Save the byte count before you overwrite %rax:

  # After read:
  movq %rax, %r12       # Save byte count in r12

  # For write:
  movq $1, %rax         # Now safe to set syscall number
  movq %r12, %rdx       # Use saved byte count


THE COMPLETE FLOW

1. Read from stdin (fd=0) into buffer
2. Save byte count from %rax to another register
3. Set up write syscall (fd=1, buffer address, saved length)
4. Call syscall
5. Exit with 0


REGISTER CHOICE

Use any register that won't be overwritten. The callee-saved
registers (%r12-%r15) are traditional choices for values you
want to preserve across function calls.
