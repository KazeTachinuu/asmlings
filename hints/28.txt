════════════════════════════════════════
LESSON 28: Saving and Restoring Registers
════════════════════════════════════════

THE PROBLEM

Registers are a limited resource. Sometimes you need a register, but
it already holds an important value.

  movq $55, %rdi          # Important value in %rdi
  # Now we need %rdi for something else...
  movq $999, %rdi         # Oops! We lost 55!


THE SOLUTION: THE STACK

Push the value before clobbering, pop it after:

  movq $55, %rdi          # Important value

  pushq %rdi              # SAVE: Store 55 on stack
  movq $999, %rdi         # Clobber %rdi freely
  # ... do more work ...
  popq %rdi               # RESTORE: Get 55 back

After the popq, %rdi is 55 again!


THE PATTERN

  pushq %REG        # Save before clobbering
  # ... code that uses %REG for something else ...
  popq %REG         # Restore after done


IMPORTANT: BALANCE YOUR PUSHES AND POPS

Every push must have a matching pop!

  pushq %rdi
  pushq %rsi
  # ... work ...
  popq %rsi        # LIFO: pop in REVERSE order!
  popq %rdi


STACK STATE

  Before push:    Stack: [...]           rdi = 55
  After push:     Stack: [...][55]       rdi = 55
  After clobber:  Stack: [...][55]       rdi = 999
  After pop:      Stack: [...]           rdi = 55


YOUR TASK

You have two spots to fill:
  1. Before the clobbering line, save the register
  2. After the clobbering line, restore it

What instructions do you need to add?
