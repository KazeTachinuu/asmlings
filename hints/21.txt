════════════════════════════════════════
LESSON 21: Conditional Jumps
════════════════════════════════════════

THE FULL SET

After cmpq $B, %A (which computes A - B):

  Signed comparisons:
    je   Jump if A == B    (Equal)
    jne  Jump if A != B    (Not Equal)
    jl   Jump if A < B     (Less)
    jle  Jump if A <= B    (Less or Equal)
    jg   Jump if A > B     (Greater)
    jge  Jump if A >= B    (Greater or Equal)

  Unsigned comparisons:
    jb   Jump if A < B     (Below)
    jbe  Jump if A <= B    (Below or Equal)
    ja   Jump if A > B     (Above)
    jae  Jump if A >= B    (Above or Equal)


SIGNED VS UNSIGNED

For positive numbers, signed and unsigned are the same.
The difference matters with negative numbers or large values.

Use jl/jg for int (signed).
Use jb/ja for size_t, pointers (unsigned).


UNCONDITIONAL JUMP

  jmp label     # Always jumps (no condition)


THE CODE

  cmpq $20, %rax     # 30 - 20 = 10 (positive)

  30 is NOT less than 20.

  Currently it uses "jmp" which ALWAYS jumps to is_less.
  But 30 >= 20, so we should NOT jump! We should fall through.

  You need a CONDITIONAL jump that only jumps when less-than is true.
  Since 30 is NOT less than 20, jl should NOT jump.


YOUR TASK

Replace "jmp" with the correct conditional jump for "less than" (signed).

Which jump instruction checks for "less than"?
