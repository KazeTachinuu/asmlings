════════════════════════════════════════
LESSON 31: Recursion - Why Stack Frames Exist
════════════════════════════════════════

THE PROBLEM WITH RECURSION

When factorial(5) calls factorial(4), what happens to n=5?

  factorial(5):
      # n = 5 is in %rdi
      call factorial      # Now %rdi has n-1 = 4
      # Oops! n=5 is gone!

The recursive call overwrites our registers!


THE SOLUTION: SAVE BEFORE, RESTORE AFTER

  factorial:
      push %rdi           # Save n on the stack
      subq $1, %rdi       # n-1 for recursive call
      call factorial      # Result in %rax
      pop %rbx            # Restore n (into a different register)
      imulq %rbx, %rax    # n * factorial(n-1)
      ret


THE STACK DURING RECURSION

  factorial(3):
      push %rdi        Stack: [3]
      call factorial(2)
          push %rdi    Stack: [3][2]
          call factorial(1)
              push %rdi    Stack: [3][2][1]
              call factorial(0)
                  returns 1
              pop %rbx     Stack: [3][2]    rbx=1
              1 * 1 = 1
          pop %rbx     Stack: [3]      rbx=2
          2 * 1 = 2
      pop %rbx         Stack: []       rbx=3
      3 * 2 = 6


BASE CASE

Don't forget the base case! Without it, recursion never stops.

  factorial:
      cmpq $0, %rdi
      jne .recurse
      movq $1, %rax       # 0! = 1
      ret


IMULQ - SIGNED MULTIPLICATION

  imulq %src, %dst    # dst = dst * src

Example:
  imulq %rbx, %rax    # rax = rax * rbx


YOUR TASK

Complete the factorial function:
  1. Push %rdi to save n
  2. Decrement %rdi
  3. Call factorial recursively
  4. Pop the saved n
  5. Multiply: result = n * result
  6. Return
