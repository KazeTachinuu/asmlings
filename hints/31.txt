════════════════════════════════════════
locals - Local Variables on the Stack
════════════════════════════════════════

WHY NEGATIVE OFFSETS?

%rbp points to the saved frame pointer. Local variables
are BELOW it on the stack (lower addresses = negative offsets).

    high addresses
         ↑
    [saved %rbp]     ← %rbp points here (offset 0)
    [first local]    ← 8 bytes below = -8(%rbp)
    [second local]   ← 16 bytes below = -16(%rbp)
         ↓
    low addresses


STORING TO A LOCAL

To store a value in a local variable:

    movq $VALUE, OFFSET(%rbp)

The offset is negative. First local is closest to %rbp.


LOADING FROM A LOCAL

To load a local variable into a register:

    movq OFFSET(%rbp), %REGISTER


ADDING FROM MEMORY

You can add a memory value directly to a register:

    addq OFFSET(%rbp), %REGISTER


YOUR TASK

Look at the stack diagram in the exercise. Figure out:
- What offset is the first local?
- What offset is the second local?

Then write four instructions to:
1. Store 10 → first local
2. Store 20 → second local
3. Load first local → %rdi
4. Add second local → %rdi
