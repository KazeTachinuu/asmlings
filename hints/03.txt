════════════════════════════════════════
LESSON 03: Moving Data Between Registers
════════════════════════════════════════

THE MOV INSTRUCTION

mov copies data from one place to another. In AT&T syntax:

  movq SOURCE, DESTINATION

The source comes FIRST (opposite of Intel syntax!).


TYPES OF OPERANDS

1. Immediate (literal value):    $42
2. Register:                     %rax
3. Memory:                       label(%rip)

Examples:
  movq $42, %rax       # Immediate → Register
  movq %rax, %rbx      # Register → Register
  movq var(%rip), %rax # Memory → Register


REGISTER-TO-REGISTER COPY

When copying between registers, no $ prefix:

  movq %rax, %rdi      # Copy RAX into RDI

This copies the VALUE in RAX to RDI. RAX is unchanged.


THE PROBLEM

The code puts 25 into %rax:
  movq $25, %rax

But the exit syscall reads from %rdi, not %rax.
The value is in the wrong place!


YOUR TASK

Add one instruction to copy the value from %rax to %rdi.

The pattern is:
  movq %SOURCE_REG, %DEST_REG

Think about which register has the value (source) and which needs it
(destination).
