════════════════════════════════════════
LESSON 18: Working with Bytes
════════════════════════════════════════

NOT EVERYTHING IS 64 BITS

Strings are made of 8-bit characters (bytes).
When working with strings, you need byte-level operations.


THE PROBLEM WITH MOVB

  movb (%rsi), %dil      # Load byte into dil (low 8 bits of rdi)

This ONLY sets the low 8 bits. The upper 56 bits keep their old value!
This can cause bugs if those bits aren't already zero.


ZERO-EXTEND: MOVZBL

  movzbl (%rsi), %edi

"Move Zero-extend Byte to Long"
  - Reads 1 byte from memory
  - Puts it in the low 8 bits of the destination
  - Fills the rest with ZEROS

Using %edi (32-bit) as destination also clears the upper 32 bits of %rdi!


SIGN-EXTEND: MOVSBL

  movsbl (%rsi), %edi

"Move Sign-extend Byte to Long"
  - Reads 1 byte from memory
  - Extends the sign bit to fill the destination

Use this for signed values (like -1 as a char).


ASCII

Characters are stored as ASCII codes:
  'A' = 65
  'B' = 66
  'a' = 97
  '0' = 48


THE .RODATA SECTION

Read-only data (strings, constants):

  .section .rodata
  msg: .ascii "ABC"       # Three bytes: 65, 66, 67


YOUR TASK

Load the first byte of 'data' (which is 'A' = 65) into %edi.

Use movzbl with the address in %rsi.
