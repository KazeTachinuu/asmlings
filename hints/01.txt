════════════════════════════════════════
LESSON 01: Your First Assembly Program
════════════════════════════════════════

WHAT IS ASSEMBLY?

Assembly is the lowest-level human-readable programming language. Each
instruction corresponds directly to machine code that the CPU executes.

Unlike high-level languages, there are no functions, objects, or automatic
memory management. You control everything.


ANATOMY OF THIS PROGRAM

  .global _start      ← Export symbol so linker can find entry point
  .text               ← Code section begins here

  _start:             ← Label marking where execution begins
      movq $60, %rax  ← Put number 60 into register RAX
      movq $0, %rdi   ← Put number 0 into register RDI
      syscall         ← Ask kernel to do something


THE SYSCALL MECHANISM

Your program runs in "user space" - it can't directly access hardware.
To do anything useful (exit, print, read files), you must ask the kernel.

The 'syscall' instruction transfers control to the Linux kernel.
The kernel reads %rax to know WHICH service you want.

Syscall 60 = exit (terminate the program)


REGISTER ROLES FOR SYSCALLS

  %rax = syscall NUMBER (which service?)
  %rdi = 1st argument
  %rsi = 2nd argument
  %rdx = 3rd argument

For exit:
  %rax = 60 (the exit syscall)
  %rdi = exit code (0 = success, non-zero = error)


AT&T SYNTAX

Notice the $ and % symbols:
  $60  = literal value 60 (immediate)
  %rax = the register named RAX

This is AT&T syntax. Intel syntax looks different but does the same thing.


YOUR TASK

This program already works! You just need to understand each line.
Once you do, remove the "# I AM NOT DONE" line.
