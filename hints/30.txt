════════════════════════════════════════
stack_frame - Setting Up a Stack Frame
════════════════════════════════════════

WHY SAVE %RBP?

%rbp is a "callee-saved" register. If a function modifies it,
it MUST restore the original value before returning.

The caller put 73 in %rbp. After my_func returns, the caller
expects %rbp to still contain 73.


THE STANDARD PATTERN

Every function that uses %rbp follows this pattern:

  PROLOGUE (at entry):
    pushq %rbp          # Save old value on stack
    movq %rsp, %rbp     # Set our frame pointer

  EPILOGUE (before return):
    popq %rbp           # Restore old value from stack
    ret                 # Return to caller


HOW IT WORKS

    pushq %rbp     →  Stack now has caller's rbp value saved
    movq %rsp, %rbp →  Our %rbp points to the saved value

    ... function does stuff, maybe clobbers %rbp ...

    popq %rbp      →  Restore caller's value from stack
    ret            →  Return with %rbp intact


YOUR TASK

Write the 4 instructions (2 prologue + 2 epilogue):

  Prologue:
    - Push %rbp onto the stack
    - Copy %rsp into %rbp

  Epilogue:
    - Pop the saved value back into %rbp
    - Return
